#include"SLICAP.h"
#include"SLIC.h"
#include"AP.h"
#include"macros.h"



SLICAP::SLICAP(std::string source_path): 
	h_source(cv::imread(source_path, cv::IMREAD_COLOR)), 
	h_labels(cv::Size(h_source.cols, h_source.rows), CV_32SC1),
	SLIC_eng(new SLIC(h_source, this)), 
	AP_eng(new AP()), 
	SLIC_result(h_labels.size(), CV_8UC3),
	AP_result(h_source.size(), CV_8UC3)
{
    d_source.upload(h_source);
    d_labels.upload(h_labels);

    h_Mat CIELAB_src;
    cv::cvtColor(h_source, CIELAB_src, cv::COLOR_BGR2Lab);
    CIELAB_planes = split_into_channels(CIELAB_src);
}

void SLICAP::run_SLIC(){ 
    //SLIC is an algorithm which oversegments an image into regularly spaced clusters of pixels with similar characteristics, known as superpixels. It is quite similar to the popular K-means algorithm, 
    //the main difference being that it explicitly takes into account spatial proximity, and seeds regularly spaced centers along a virtual grid, so as to ultimately produce a field of superpixels. 

    std::cout << "sampling centers" << std::endl;
    SLIC_eng->sample_centers(); 
    //first, we sample a number of points from the source image to serve as centers, at regular intervals S.

    do {
        std::cout << "assigning pixels to centers" << std::endl;
        SLIC_eng->assign_pixels_to_centers();
        //for each pixel, given the 9 centers closest to it in space, we determine which of these centers is the nearest to it according to the distance formula given by the paper.
        //this formula consists of the euclidean distance between the color vectors of the pixel and the center, plus the distance between their coordinates tempered by the 'density' parameter. 

        std::cout << "updating centers" << std::endl;
        SLIC_eng->update_centers();
        //for each center, given all pixels which are labeled with its ID, we calculate the geometric mean of these pixels and shift the center to this new poisition.
        //we then record the average distance that the centers were displaced, for the purpose of checking for convergence.


    } while (SLIC_eng->displacement > SLIC_eng->displacement_threshold);
    //once the average displacement of the centers falls below the threshold, the algorithm has converged.

    std::cout << "enforcing connectivity" << std::endl;
    SLIC_eng->enforce_connectivity(); 
    //after producing the superpixels, we need to ensure that regions with the same label are connected, and that the values of these labels run sequentially from 0 - K with no missed values.
    //the exact process is somewhat complex, and detailed further within the enforce_connectivity function.
}

void SLICAP::run_AP(){ 
    //Affinity Propagation is a clustering algorithm which associates data points by recursively passing messages between them. The task of affinity propagation is to associate each data point with
    //another data point, known as its exemplar, which fairly represents that point and others like it. The fun part is that the reulting number of clusters are not predetermined, but emerge organically.

    AP_eng->calculate_average_color_vectors();
    //before we begin Affinity Propagation, we must process the data we would like to compare. In this case, that means taking the average CIELAB vector of each superpixel determined previosuly by SLIC,
    //and assigning to it the average of the CIELAB vectors of its constituent pixels in the original image. 

    AP_eng->generate_similarity_matrix();
    //before we begin passing messages, we must determine the baseline similarity between each pair of data points. here the negative euclidean distance between their color vectors. after finding the similarity 
    //for each pair, we must set all elements along the diagonal to the 'preference value'. This value influences how many clusters are generated by the algorithm. We are using the lowest value in the matrix.

    while (AP_eng->constant_cycles < AP_eng->num_constant_cycles_for_convergence) {
        AP_eng->update_responsibility_matrix();
        //the responsibility matrix represents the messages sent from each data point to each potential exemplar. These messages reflect how well-suited that particular potential exemplar is  
        //to serve as the exemplar for a particular data point, taking into account other potential exemplars for that data point. 

        AP_eng->update_availibility_matrix();
        //the availibility matrix is the second set of messages, and sort of the inverse of the first. The availbility communicates from each potential exemplar to each data point how appropriate 
        //it would be for the data point to choose that potential exemplar, taking into account the support from other data points for the potential exemplar.

        AP_eng->update_critereon_matrix();
        //the critereon matrix is simply the sum of the availibility and responsibility matrices - or, in other words, the synthesis of their messages. Each data point is assigned the greatest-valued 
        //potential exemplar. If this happens to be the data point itself, this means that the data point is in fact an exemplar.

        AP_eng->extract_and_examine_exemplars();
        //here we actuallly carry out the process described above of extracting the exemplars from the critereon matrix. Then we check the new exemplars against the ones determined in the previous 
        //iteration. We will make note of how many have changed between the two lists, and declare convergence once no change occurs for a certain number of iterations.
    }

    AP_eng->segment_image_using_exemplars();
    //now that we have the exemplars, we will create the final segmented image to be displayed as the result.

}

void SLICAP::display_SLIC_result(){
    d_labels.download(h_labels);

    for(int col = 0; col < h_labels.cols; col++){
        for(int row = 0; row < h_labels.rows; row++){

            int label = h_labels.at<int>(col, row);
            int label_range = label % (256 * 3);
            uchar label_r = label_range % 256;
            uchar label_g = (label_range - label_r) % 256;
            uchar label_b = (label_range - label_g - label_r) % 256;
            SLIC_result.at<cv::Vec3b>(col, row) = {label_b, label_g, label_r};

        }
    }
    
    cv::imshow("segmented image", SLIC_result);
    cv::waitKey(0);
}

void SLICAP::display_AP_result(){
    cv::imshow("segmented image", AP_result);
    cv::waitKey(0);
}

std::vector<d_Mat> SLICAP::split_into_channels(h_Mat input){
    vector<h_Mat> split;
    cv::split(input, split);
    d_Mat d_L, d_A, d_B;
    d_L.upload(split[0]);
    d_A.upload(split[1]);
    d_B.upload(split[2]);
    return { d_L, d_A, d_B };
}

void SLICAP::reset_flag(){
    flag = 0;
    CUDA_SAFE_CALL(cudaMalloc((void**)&d_flag, sizeof(uint)));
    CUDA_SAFE_CALL(cudaMemcpy(d_flag, h_flag, sizeof(uint), cudaMemcpyHostToDevice));
}

void SLICAP::read_flag(){
    CUDA_SAFE_CALL(cudaMemcpy(d_flag, h_flag, sizeof(uint), cudaMemcpyHostToDevice));
    CUDA_SAFE_CALL(cudaFree(d_flag));
}